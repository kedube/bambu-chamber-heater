#
# Bambu Chamber Heater Modbus Controller for Sinilink XY-SA/ST series temperature controllers using the 
# ESP8285 (XY-WFPOW) microcontroller. Designed to work with Bambu 3D Printers as a chamber heater controller.
# Copyright (C) 2026    Katherine Dubé
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

substitutions:
  device_name: "chamber-heater"
  friendly_name: "Chamber Heater Controller"
  device_description: "ESP8285-based Modbus interface for Sinilink XY-SA/ST temperature controllers"
  device_area: "Office"
  bambu_printer_entity_id: !secret bambu_printer_id
  sw_version: "1.5.1"
  pla_temp: "22" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  tpu_temp: "25" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  petg_temp: "35" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pctg_temp: "35" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  abs_temp: "55" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  asa_temp: "55" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pc_temp: "80" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pet_temp: "50" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pa_temp: "60" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pa6_temp: "80" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pa12_temp: "60" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pa612_temp: "25" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  ppa_temp: "70" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pps_temp: "80" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pp_temp: "55" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  pe_temp: "75" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  paht_temp: "55" # Degrees Celsius - adjust as needed for your specific filament and printer setup
  # Maximum safe temperature rise rate (degrees per second)
  # 0.5°C/sec = 30°C/min is reasonable for chamber heating but would indicate runaway heating
  # Only checks RISING temperature - falling is normal when heater turns off
  max_temp_rise_rate: "0.5"
  baud_rate: "115200"
  modbus_slave_address: "0x1"
  modbus_update_interval: "10s"
  temp_multiplier: "0.1"
  temp_read_lambda: "return x * 0.1f;"
  temp_write_lambda: "return (int16_t) lroundf(x * 10.0f);"
  # Communication timeout in milliseconds (90000ms = 90s)
  # Must be > 3x modbus_update_interval (10s) to avoid false positives
  # Checked every 30s by interval task
  comms_timeout_ms: "90000"

packages:
  select_units: !include 
    # Select the appropriate temperature unit file to include based on your preference. 
    # Both files define the same entities, but with different units and value ranges.
    file: celsius.yaml
    #file: fahrenheit.yaml

globals:
  # Filament type aliases - maps Bambu filament names to preset names
  - id: filament_type_map
    type: std::map<std::string, std::string>
    restore_value: no
    initial_value: |-
      {
        // PLA variants
        {"PLA", "PLA"},
        {"PLA SILK", "PLA"},
        {"PLA+", "PLA"},
        {"PLA-CF", "PLA"},
        {"MATTE PLA", "PLA"},
        {"PLA HIGH SPEED", "PLA"},
        
        // TPU variants
        {"TPU", "TPU"},
        {"TPU 95A", "TPU"},
        {"TPU 85A HF", "TPU"},
        
        // PETG variants
        {"PETG", "PETG"},
        {"PETG HF", "PETG"},
        {"PETG-CF", "PETG"},
        {"PETG-RCF", "PETG"},
        {"PETG-ESD", "PETG"},
        
        // PCTG variants
        {"PCTG", "PCTG"},
        
        // ABS variants
        {"ABS", "ABS"},
        {"ABS-GF", "ABS"},
        
        // ASA variants
        {"ASA", "ASA"},
        {"ASA-CF", "ASA"},
        {"ASA-AERO", "ASA"},
        
        // PC variants
        {"PC", "PC"},
        {"PC FR", "PC"},
        
        // PET variants
        {"PET", "PET"},
        {"PET-CF", "PET"},
        
        // PA variants
        {"PA", "PA"},
        {"PA-CF", "PA"},
        
        // PA6 variants
        {"PA6", "PA6"},
        {"PA6-GF", "PA6"},
        {"PA6-CF", "PA6"},
        
        // PA12 variants
        {"PA12", "PA12"},
        {"PA12-CF", "PA12"},
        
        // PA612 variants
        {"PA612", "PA612"},
        {"PA612-CF", "PA612"},
        
        // PPA variants
        {"PPA-GF", "PPA"},
        {"PPA-CF", "PPA"},
        
        // PP variants
        {"PP", "PP"},
        {"PP-GF", "PP"},
        {"PP-CF", "PP"},
        
        // PPS variants
        {"PPS", "PPS"},
        {"PPS-CF", "PPS"},
        
        // PE variants
        {"PE", "PE"},
        {"PE-CF", "PE"},
        
        // PAHT variants
        {"PAHT-CF", "PAHT"}
      }
  # Restart confirmation flag - user must enable before restarting
  - id: restart_confirmed
    type: bool
    restore_value: no
    initial_value: 'false'
  # Modbus debugging flag - enables verbose UART logging when true
  - id: modbus_debugging
    type: bool
    restore_value: no
    initial_value: 'false'
  # Timestamp of last temperature update - used by communication watchdog
  - id: last_temp_update_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  # Communication fault latch - prevents duplicate error messages
  - id: comms_fault_latched
    type: bool
    restore_value: no
    initial_value: 'false'
  # Flag indicating if we have at least one valid temperature reading
  # Used to prevent false rate-of-change alarms on first boot
  # Using a flag instead of checking temp != 0.0 because 0.0°C is a valid temperature
  - id: has_last_valid_temp
    type: bool
    restore_value: no
    initial_value: 'false'
  # Previous temperature reading for rate-of-change calculation
  # Initialized to 0.0 but only used when has_last_valid_temp is true
  - id: last_valid_temp
    type: float
    restore_value: no
    initial_value: '0.0'
  # Timestamp of last temperature sample in milliseconds
  # Used with unsigned arithmetic to handle millis() wraparound at 49.7 days
  - id: last_temp_sample_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  # Timestamp when first emergency condition occurred
  # Set to 0 when emergency cleared, preserves first emergency time if multiple triggers
  - id: emergency_stop_timestamp
    type: unsigned long
    restore_value: no
    initial_value: '0'
  # Boot initialization complete flag
  # Prevents emergency stop triggers during initial sensor synchronization
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'
  # Home Assistant API connection status - used to trigger emergency stop if disconnected for too long
  - id: api_connection
    type: bool
    restore_value: no
    initial_value: 'false'

script:
  # Ensures controller's temperature unit matches the configured unit in this file
  # Runs on boot to sync controller if it was changed via physical buttons
  # Uses queued mode to handle multiple calls during startup
  - id: write_temp_unit
    mode: queued
    then:
      - if:
          condition:
            lambda: |-
              return id(temperature_unit).state != "${temp_unit}";
          then:
            - select.set:
                id: set_temperature_unit
                option: "${temp_unit}"
  # Safety timeout for restart confirmation
  # User must enable restart_confirmation switch within 10 seconds before pressing restart
  # Prevents accidental restarts during operation
  - id: restart_confirm_timeout
    mode: restart
    then:
      - delay: 10s  # 10 second window to confirm restart
      - if:
          condition:
            lambda: "return id(restart_confirmed);"
          then:
            - logger.log:
                format: "Restart confirmation timed out"
                level: INFO
            - switch.turn_off: restart_confirmation
  # Safety check for Bambu printer connectivity
  # Forces emergency stop whenever printer online sensor is OFF
  - id: check_bambu_printer_online
    mode: queued
    then:
      - if:
          condition:
            lambda: |-
              return id(boot_complete) &&
                     !id(bambu_printer_online).state;
          then:
            - logger.log:
                format: "EMERGENCY: Bambu 3D Printer is offline - forcing emergency stop"
                level: WARN
            - switch.turn_on: emergency_stop
  # Auto-select chamber temperature preset based on Bambu printer's filament type
  # Reads current filament type and sets appropriate chamber heating preset
  - id: auto_select_filament_preset
    mode: queued
    then:
      - lambda: |-
          std::string filament = id(bambu_filament_type).state;
          std::string filament_upper = filament;
          
          // Convert to uppercase
          std::transform(filament_upper.begin(), filament_upper.end(),
                       filament_upper.begin(), ::toupper);
          
          // Look up preset name from filament type
          auto type_it = id(filament_type_map).find(filament_upper);
          
          if (type_it != id(filament_type_map).end()) {
            std::string preset_name = type_it->second;
            
            // Set the preset
            auto call = id(filament_temp_preset).make_call();
            call.set_option(preset_name);
            call.perform();
            
            ESP_LOGI("bambu", "Auto-set chamber temp preset to %s (from filament type: %s)", 
                     preset_name.c_str(), filament.c_str());
          } else {
            ESP_LOGW("bambu", "Unknown filament type: %s - keeping current preset", 
                     filament.c_str());
          }

esp8266:
  board: esp8285
  restore_from_flash: true
  framework:
    version: latest

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: ${device_description}
  area: ${device_area}
  on_boot:
    priority: 200
    then:
      - script.execute: write_temp_unit
      # Wait for initial modbus synchronization before enabling emergency checks
      # Prevents false emergency stops during boot
      - delay: 30s
      - lambda: |-
          id(boot_complete) = true;
          ESP_LOGI("boot", "Boot complete - emergency stop checks now active");
      - script.execute: check_bambu_printer_online
  #platformio_options:
  #  upload_port: ${device_name} + ".local"
  #  upload_flags: -a !secret ota_password
  #  upload_protocol: espota

# Enable Home Assistant API
api:
  # Comment/uncomment encryption key if you want to use API features or integrate with Home Assistant
  encryption:
    key: !secret encryption_key

logger:
  level: DEBUG
  # Log Levels: NONE, ERROR, WARN, INFO, DEBUG, VERBOSE, VERY_VERBOSE
  # Disable logging via UART, since we're using this for modbus communication
  baud_rate: 0 #Serial logging can be disabled by setting baud_rate: 0.

# Enable status LED
status_led:
  pin:
    number: GPIO2
    inverted: true

ota:
  # Keep standard ESPHome OTA (Dashboard/CLI)
  - platform: esphome
    password: !secret ota_password
  # And enable OTA uploads via the web UI
  - platform: web_server

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA2
  power_save_mode: none
  fast_connect: on
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret ap_wifi_ssid
    password: !secret ap_wifi_password
  #manual_ip:
  #  static_ip: !secret static_ip
  #  gateway: !secret gateway
  #  subnet: !secret subnet
  #  dns1: !secret dns1
  #  dns2: !secret dns2

captive_portal:

uart:
  - id: uart_bus
    tx_pin: GPIO1
    rx_pin: GPIO3
    baud_rate: ${baud_rate}
    data_bits: 8
    parity: NONE
    stop_bits: 1   
    debug:
      direction: BOTH
      dummy_receiver: false
      after:
        delimiter: "\n"    
      sequence:
        - lambda: |-
            if (id(modbus_debugging)) {
              UARTDebug::log_hex(direction, bytes, ' '); // Verbose Hex
            } 

# ========================================
# MODBUS REGISTER MAP - Sinilink XY-SA/ST
# ========================================
#
# Register addresses for XY-SA/ST temperature controller
# All registers are 16-bit holding registers unless otherwise noted
# Temperature values use signed words (S_WORD) with 0.1 multiplier
#
# ADDRESS | TYPE   | NAME                    | RANGE/VALUES        | DESCRIPTION
# --------|--------|-------------------------|---------------------|------------------------------------------
# 0x0000  | U_WORD | Controller Status       | 0=Stopped, 1=Active | Main relay/controller state
# 0x0001  | U_WORD | Temp Sensor Status      | 0=Connected, 1=Disc | Temperature sensor connection status
# 0x0002  | U_WORD | Delay Time Remaining    | 0-999 seconds       | Countdown timer for delayed start
# 0x0003  | S_WORD | Current Temperature     | -400 to 1100 (*0.1) | Current measured temperature
# 0x0004  | U_WORD | Temperature Unit        | 0=Celsius, 1=Fahr   | Display and control temperature unit
# 0x0005  | U_WORD | Controller Mode         | 0=Heating, 1=Cooling| Operating mode (heating vs cooling)
# 0x0006  | S_WORD | Low Temp Threshold      | -400 to 850 (*0.1)  | Temperature to start heating/cooling
# 0x0007  | S_WORD | High Temp Threshold     | -400 to 850 (*0.1)  | Temperature to stop heating/cooling
# 0x0008  | S_WORD | High Temp Alarm         | -400 to 1100 (*0.1) | High temperature alarm threshold
# 0x0009  | S_WORD | Low Temp Alarm          | -400 to 1100 (*0.1) | Low temperature alarm threshold
# 0x000A  | U_WORD | Delay Start Time        | 0-999 seconds       | Delay start duration setting
# 0x000B  | S_WORD | Temperature Offset      | -100 to 100 (*0.1)  | Temperature calibration offset
# 0x000C  | BOOL   | Alarm Active            | 0=No, 1=Yes         | Temperature alarm status (read-only)
# 0x000D  | BOOL   | Alarm Sound             | 0=Off, 1=On         | Enable/disable alarm beeper
# 0x000E  | BOOL   | High Temp Alarm Enable  | 0=Off, 1=On         | Enable high temperature alarm
# 0x000F  | BOOL   | Low Temp Alarm Enable   | 0=Off, 1=On         | Enable low temperature alarm
# 0x0010  | BOOL   | Delay Start Enable      | 0=Off, 1=On         | Enable delayed start feature
# 0x0011  | BOOL   | Emergency Stop          | 0=Off, 1=On         | Emergency stop/disable controller
# 0x0012  | U_WORD | Modbus Address          | 1-247               | Modbus slave address (requires reboot)
# 0x0013  | U_WORD | Modbus Baudrate         | See baudrate map    | Serial communication speed
# 0x0014  | BOOL   | Sleep Mode              | 0=Off, 1=On         | Display sleep/power saving mode
# 0x0015  | U_WORD | Backlight Level         | 0-7                 | Display backlight brightness (0=off)
#
# Baudrate Map (0x0013):
#   0=9600, 1=14400, 2=19200, 3=38400, 4=56000, 5=57600, 6=115200
#
# Temperature Value Encoding:
#   - Stored as signed 16-bit integers representing temperature in tenths of degrees
#   - Actual temperature = register_value * 0.1
#   - Example: register value 235 = 23.5°C
#
# Safety Notes:
#   - Always enable high temp alarm (0x000E) for safety
#   - Set high temp alarm (0x0008) above normal operating range
#   - Emergency stop (0x0011) immediately disables heating/cooling
#   - Monitor sensor status (0x0001) for disconnection events
#   - Communication timeout (>90s) triggers automatic emergency stop
#
# IMPORTANT SAFETY CONFIGURATION:
#   - Registers 0x0006/0x0007 (thresholds): Can have low > high in cooling mode
#   - Registers 0x0008/0x0009 (alarms): Can have low > high in cooling mode
#   - Always verify critical settings after modbus address or baudrate changes
#
# ========================================

modbus:
  send_wait_time: 1s
  uart_id: uart_bus
  disable_crc: false
  role: client
  id: modbus1

modbus_controller:
  - id: modbus_device
    address: ${modbus_slave_address}  # Default address of the Modbus slave device on the bus
    modbus_id: modbus1
    setup_priority: -10
    update_interval: ${modbus_update_interval}
    command_throttle: 300ms
    

sensor:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Delay Time Remaining"
    device_class: duration
    state_class: measurement
    address: 0x0002
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "s"
    id: delay_time_remaining
    icon: "mdi:timer-outline"
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Current Temp"
    device_class: temperature
    state_class: measurement
    address: 0x0003
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "${temp_unit_label}"
    accuracy_decimals: 1
    filters:
      - multiply: ${temp_multiplier}
    on_value:
      then:
        - lambda: |-
            uint32_t now = millis();
            bool emergency_active = id(emergency_stop).state;  // Cache state to reduce Modbus reads
            id(last_temp_update_ms) = now;
            id(comms_fault_latched) = false;

            // Rate of change detection (runaway heating protection)
            // NOTE: Only checks for RISING temperature - this is intentional:
            //   - Rising too fast = runaway heating (fire risk) → emergency stop
            //   - Falling fast = heater turned off (normal) → no emergency
            //   - Runaway cooling is caught by low_temp_alarm check below
            if (id(has_last_valid_temp) && id(last_temp_sample_ms) != 0) {
              // Calculate actual elapsed time for accurate rate calculation
              // Uses unsigned arithmetic which safely handles millis() wraparound
              uint32_t elapsed_ms = now - id(last_temp_sample_ms);
              float temp_delta = x - id(last_valid_temp);
              float time_delta_sec = elapsed_ms / 1000.0f;

              if (time_delta_sec > 0.0f) {
                float temp_rate = temp_delta / time_delta_sec;

                if (id(boot_complete) && id(over_temp_shutoff).state && temp_rate > ${max_temp_rise_rate}) {
                  if (!emergency_active) {
                    id(emergency_stop).turn_on();
                    ESP_LOGE("safety",
                      "EMERGENCY: Temperature rising too fast: %.2f%s/s (max: ${max_temp_rise_rate}%s/s)",
                      temp_rate, "${temp_unit_label}", "${temp_unit_label}");
                  }
                }
              }
            }
            id(last_temp_sample_ms) = now;
            id(last_valid_temp) = x;
            id(has_last_valid_temp) = true;
        # High temperature alarm - absolute safety limit
        # Triggers regardless of heating/cooling mode
        # Only check after boot complete and alarm sensor is initialized (not NaN)
        - if:
            condition:
              lambda: |-
                return id(boot_complete) &&
                       id(over_temp_shutoff).state &&
                       !isnan(id(high_temp_alarm).state) &&
                       x > id(high_temp_alarm).state &&
                       !id(emergency_stop).state;
            then:
              - switch.turn_on: emergency_stop
              - lambda: |-
                  ESP_LOGE("safety",
                    "EMERGENCY: Temperature %.1f%s exceeds High Temperature Alarm: %.1f%s",
                    id(current_temperature).state,
                    "${temp_unit_label}",
                    id(high_temp_alarm).state,
                    "${temp_unit_label}"
                  );
        # Low temperature alarm - detects sensor failure or runaway cooling
        # Only triggers when controller is ACTIVE (heating or cooling)
        # When STOPPED, temp naturally falls and is not an emergency
        # Only check after boot complete and alarm sensor is initialized (not NaN)
        # NOTE: Checks both heating AND cooling modes:
        #   - Heating mode + low temp = heater failure or sensor fault
        #   - Cooling mode + low temp = runaway cooling or sensor fault
        - if:
            condition:
              lambda: |-
                return id(boot_complete) &&
                       id(over_temp_shutoff).state &&
                       !isnan(id(low_temp_alarm).state) &&
                       id(controller_status).state == "Active" &&
                       x < id(low_temp_alarm).state &&
                       !id(emergency_stop).state;
            then:
              - switch.turn_on: emergency_stop
              - lambda: |-
                  ESP_LOGE("safety",
                    "EMERGENCY: Temperature %.1f%s below Low Temperature Alarm: %.1f%s (possible sensor failure)",
                    id(current_temperature).state,
                    "${temp_unit_label}",
                    id(low_temp_alarm).state,
                    "${temp_unit_label}"
                  );
    id: current_temperature
    icon: "mdi:thermometer"
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: wifi_signal
    name: "WiFi Signal Strength"
    device_class: signal_strength
    state_class: measurement
    unit_of_measurement: "dBm"
    update_interval: 60s
    id: wifi_signal_strength
    icon: "mdi:wifi-strength-3"
    web_server:
      sorting_group_id: sorting_group_diagnostic

binary_sensor:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Alarm Active"
    address: 0x000C
    register_type: holding
    on_press:
      then: 
        - logger.log:
            format: "Warning temperature alarm triggered!"
            level: WARN
    id: alarm_active
    icon: "mdi:alarm-bell"
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: homeassistant
    name: "Bambu Printer Online"
    entity_category: diagnostic
    entity_id: binary_sensor.${bambu_printer_entity_id}_online
    id: bambu_printer_online
    internal: true
    on_state:
      then:
        - script.execute: check_bambu_printer_online

text_sensor:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Controller Status"
    address: 0x0000
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    id: controller_status
    icon: "mdi:thermostat"
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      if (v == 0) return std::string("Stopped");
      if (v == 1) return std::string("Active");
      return std::string("Unknown");
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Temp Sensor Status"
    address: 0x0001 
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    id: sensor_status
    icon: "mdi:information-outline"
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      if (v == 0) return std::string("Connected");
      if (v == 1) return std::string("Disconnected");
      return std::string("Unknown");
    on_value:
      then:
        - if:
            condition:
              lambda: "return x == \"Disconnected\" && !id(emergency_stop).state;"
            then:
              # Sensor disconnection is critical - cannot safely operate without temperature data
              # Force emergency stop immediately
              - switch.turn_on: emergency_stop
              - lambda: 'ESP_LOGE("safety", "EMERGENCY: Temperature sensor disconnected, forcing emergency stop");'
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Temp Unit"
    address: 0x0004
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    id: temperature_unit
    icon: "mdi:temperature-auto"
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      if (v == 0) return std::string("Celsius");
      if (v == 1) return std::string("Fahrenheit");
      return std::string("Unknown");
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Controller Mode"
    address: 0x0005
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    id: controller_mode
    icon: "mdi:thermostat-cog"
    lambda: |-
      uint16_t v = modbus_controller::word_from_hex_str(x, 0);
      if (v == 0) return std::string("Heating");
      if (v == 1) return std::string("Cooling");
      return std::string("Unknown");
    web_server:
      sorting_group_id: sorting_group_sensors

  - platform: version
    name: "Firmware Version"
    id: firmware_version
    hide_timestamp: true
    icon: "mdi:chip"
    web_server:
      sorting_group_id: sorting_group_diagnostic

  - platform: template
    name: "WIFI SSID"
    entity_category: diagnostic
    id: wifi_ssid
    icon: "mdi:wifi"
    lambda: |-
      return std::string(!WiFi.SSID().isEmpty() ? WiFi.SSID().c_str() : "Not Connected");
    web_server:
      sorting_group_id: sorting_group_diagnostic

  - platform: template
    name: "IP Address"
    entity_category: diagnostic
    id: ip_address
    icon: "mdi:ip"
    lambda: |-
      if (WiFi.isConnected()) {
        return std::string(WiFi.localIP().toString().c_str());
      } else {
        return std::string("Not Connected");
      }
    web_server:
      sorting_group_id: sorting_group_diagnostic
 
  - platform: template
    name: "Software Version"
    entity_category: diagnostic
    id: software_version
    icon: "mdi:information-variant"
    lambda: |-
      return std::string("${sw_version}");
    web_server:
      sorting_group_id: sorting_group_diagnostic

  - platform: uptime
    name: "System Uptime"
    format:
      separator: " "
    id: system_uptime
    icon: "mdi:clock-start"
    web_server:
      sorting_group_id: sorting_group_diagnostic

  - platform: template
    name: "Emergency Stop Time"
    entity_category: diagnostic
    id: emergency_stop_time_sensor
    icon: "mdi:clock-alert"
    lambda: |-
      if (id(emergency_stop_timestamp) == 0) {
        return std::string("Not Active");
      }
      // Calculate elapsed time since first emergency condition
      // Uses unsigned arithmetic - safely handles millis() wraparound at ~49.7 days
      unsigned long elapsed_sec = (millis() - id(emergency_stop_timestamp)) / 1000;

      // Calculate time components (days, hours, minutes, seconds)
      unsigned long days = elapsed_sec / (24UL * 3600);
      unsigned long remaining = elapsed_sec % (24UL * 3600);

      unsigned long hours = remaining / 3600;
      remaining %= 3600;

      unsigned long minutes = remaining / 60;
      unsigned long seconds = remaining % 60;

      // Build the output string using single buffer allocation (more efficient than string concatenation)
      char buffer[64];
      char* p = buffer;

      if (days > 0) p += sprintf(p, "%lud ", days);
      if (hours > 0) p += sprintf(p, "%luh ", hours);
      if (minutes > 0) p += sprintf(p, "%lum ", minutes);
      if (seconds > 0 || p == buffer) p += sprintf(p, "%lus ", seconds);
      sprintf(p, "ago");

      return std::string(buffer);
    update_interval: 5s
    web_server:
      sorting_group_id: sorting_group_system

  - platform: homeassistant
    name: "Bambu Printer Status"
    entity_id: sensor.${bambu_printer_entity_id}_print_status
    entity_category: diagnostic
    id: bambu_printer_status
    icon: "mdi:printer-3d"
    on_value:
      then:
        - lambda: |-
            if (x == "finish" || x == "failed" || x == "offline") {
              // Print ended - turn off chamber heater
              auto call = id(filament_temp_preset).make_call();
              call.set_option("Off");
              call.perform();
              ESP_LOGI("bambu", "Print ended, automatically turning off chamber heater");
            } else if (x == "running" || x == "prepare" || x == "slicing") {
              // Print started - auto-select chamber temp based on current filament
              ESP_LOGI("bambu", "Print started, auto-selecting chamber temperature");
            }
        - if:
            condition:
              lambda: |-
                return x == "running" || x == "prepare" || x == "slicing";
            then:
              - script.execute: auto_select_filament_preset

  - platform: homeassistant
    name: "Bambu Active Filament Type"
    entity_id: sensor.${bambu_printer_entity_id}_active_tray
    attribute: "type"
    entity_category: diagnostic
    id: bambu_filament_type
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("bambu", "Active filament type changed to: %s", x.c_str());
        - if:
            condition:
              lambda: |-
                // Only auto-select if printer is actively printing or preparing
                return id(bambu_printer_status).state == "running" ||
                       id(bambu_printer_status).state == "prepare" ||
                       id(bambu_printer_status).state == "slicing";
            then:
              - script.execute: auto_select_filament_preset
    web_server:
      sorting_group_id: sorting_group_diagnostic

number:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Delay Start Time"
    address: 0x000A
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "s"
    min_value: 0
    max_value: 999
    step: 1
    mode: box
    entity_category: config
    id: delay_start_time
    icon: "mdi:timer-sand"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Modbus Address"
    address: 0x0012
    register_type: holding
    value_type: U_WORD
    min_value: 1
    max_value: 247
    step: 1
    mode: box
    entity_category: config
    id: modbus_slave_address
    icon: "mdi:hexadecimal"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Backlight Level"
    address: 0x0015
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 7
    step: 1
    mode: box
    entity_category: config
    id: backlight_level
    icon: "mdi:lightbulb"
    web_server:
      sorting_group_id: sorting_group_settings

select:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Set Temperature Unit"
    address: 0x0004
    value_type: U_WORD
    use_write_multiple: false
    entity_category: config
    optionsmap:
      "Celsius": 0
      "Fahrenheit": 1
    id: set_temperature_unit
    icon: "mdi:temperature-auto"
    internal: true
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Modbus Baudrate"
    address: 0x0013
    value_type: U_WORD
    use_write_multiple: false
    entity_category: config
    optionsmap:
      "9600": 0
      "14400": 1
      "19200": 2
      "38400": 3
      "56000": 4
      "57600": 5
      "115200": 6
    id: modbus_baudrate
    icon: "mdi:console"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: template
    name: "Filament Temp Preset"
    optimistic: true
    restore_value: true
    options:
      - "Off"
      - "PLA"
      - "TPU"
      - "PETG"
      - "PCTG"
      - "ABS"
      - "ASA"
      - "PC"
      - "PET"
      - "PA"
      - "PA6"
      - "PA12"
      - "PA612"
      - "PPA"
      - "PP"
      - "PE"
      - "PAHT"
      - "User-defined"
    initial_option: "User-defined"
    on_value:
      then:
        - lambda: |-
            if (x == "Off") {
              id(emergency_stop).turn_on();
              ESP_LOGI("preset", "Emergency stop activated");
              return;
            }
            
            if (x == "User-defined") {
              ESP_LOGI("preset", "User-defined mode selected");
              return;
            }
            
            // Look up preset temperatures
            auto it = id(filament_presets).find(x);
            if (it != id(filament_presets).end()) {
              float temp_start = it->second.first;
              float temp_stop = it->second.second;
              
              auto call_start = id(temp_threshold_start).make_call();
              call_start.set_value(temp_start);
              call_start.perform();
              
              auto call_stop = id(temp_threshold_stop).make_call();
              call_stop.set_value(temp_stop);
              call_stop.perform();
              
              if (id(emergency_stop).state == 1) {
                id(emergency_stop).turn_off();
                ESP_LOGI("preset", "Emergency stop deactivated");
              }
              
              ESP_LOGI("preset", "%s mode set (%.1f${temp_unit_label} - %.1f${temp_unit_label})",
                       x.c_str(), temp_start, temp_stop);
            }
    entity_category: config
    id: filament_temp_preset
    icon: "mdi:thermometer-lines"
    web_server:
      sorting_group_id: sorting_group_settings

switch: 
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Alarm Sound"
    address: 0x000D
    register_type: holding
    use_write_multiple: false
    entity_category: config
    id: alarm_sound
    icon: "mdi:alarm-check"
    web_server:
      sorting_group_id: sorting_group_settings
 
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "High Temp Alarm"
    address: 0x000E
    register_type: holding
    use_write_multiple: false
    entity_category: config
    id: high_temp_alarm_enable
    icon: "mdi:temperature-alert"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Low Temp Alarm"
    address: 0x000F
    register_type: holding
    use_write_multiple: false
    entity_category: config
    id: low_temp_alarm_enable
    icon: "mdi:temperature-alert"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Delay Start"
    address: 0x0010
    register_type: holding
    use_write_multiple: false
    entity_category: config
    id: delay_start
    icon: "mdi:timer-check-outline"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Emergency Stop"
    address: 0x0011
    register_type: holding
    use_write_multiple: false
    id: emergency_stop
    icon: "mdi:car-brake-alert"
    on_turn_on:
      - lambda: |-
          // Set timestamp only if not already set
          // Preserves time of first emergency if multiple conditions trigger
          if (id(emergency_stop_timestamp) == 0) {
            id(emergency_stop_timestamp) = millis();
          }
      - logger.log:
          format: "Emergency stopped enabled"
          level: INFO
    on_turn_off:
      - lambda: |-
          // Clear timestamp when emergency is manually cleared
          // Allows new emergency events to be tracked
          id(emergency_stop_timestamp) = 0;
      - logger.log:
          format: "Emergency stopped disabled"
          level: INFO
    web_server:
      sorting_group_id: sorting_group_system

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: "Sleep"
    address: 0x0014
    register_type: holding
    use_write_multiple: false
    entity_category: config
    id: sleep_switch
    icon: "mdi:power-sleep"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: template
    name: "Over Temp Shutoff"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      then:
        - logger.log:
            format: "Over temp shutoff enabled"
            level: INFO
    turn_off_action:
      then:
        - logger.log:
            format: "Over temp shutoff disabled"
            level: INFO
    id: over_temp_shutoff
    icon: "mdi:car-brake-temperature"
    web_server:
      sorting_group_id: sorting_group_system

  # Raises logger level to DEBUG only while this switch is enabled.
  - platform: template
    name: "Modbus Debugging"
    optimistic: true
    turn_on_action:
      then:
        - logger.set_level: DEBUG
        - lambda: |-
            id(modbus_debugging) = true;
            ESP_LOGI("switch", "Modbus Debugging enabled");
    turn_off_action:
      then:
        - logger.set_level: INFO
        - lambda: |-
            id(modbus_debugging) = false;
            ESP_LOGI("switch", "Modbus Debugging disabled");
    entity_category: config
    id: modbus_debugging_switch
    icon: "mdi:bug"
    web_server:
      sorting_group_id: sorting_group_settings

  - platform: template
    name: "Restart Confirmation"
    optimistic: true
    turn_on_action:
      - globals.set:
          id: restart_confirmed
          value: 'true'
      - script.execute: restart_confirm_timeout
    turn_off_action:
      - script.stop: restart_confirm_timeout
      - globals.set:
          id: restart_confirmed
          value: 'false'
    id: restart_confirmation
    icon: "mdi:shield-check-outline"
    web_server:
      sorting_group_id: sorting_group_system

button:
  - platform: template
    name: "Restart"
    id: restart_button
    on_press:
      - if:
          condition:
            lambda: 'return id(restart_confirmed);'
          then:
            - logger.log:
                format: "Restarting device..."
                level: WARN
            - switch.turn_off: restart_confirmation
            - button.press: internal_restart
          else:
            - logger.log:
                format: "Restart denied: Click the restart confirmation switch first!"
                level: INFO
    icon: "mdi:restart"
    web_server:
      sorting_group_id: sorting_group_system

  - platform: restart
    name: "Internal Restart"
    id: internal_restart
    internal: true

interval:
  # Communication watchdog - monitors for stale temperature data
  # Checks every 30 seconds if temperature updates are being received
  # Triggers emergency stop if no updates for comms_timeout_ms (90s)
  - interval: 30s
    then:
      # Check Modbus temperature communication
      - if:
          condition:
            lambda: |-
              // Skip if already latched to avoid duplicate log messages
              if (id(comms_fault_latched)) return false;
              // Skip if no temperature readings received yet (initial state)
              if (id(last_temp_update_ms) == 0) return false;
              // Check if time since last update exceeds timeout threshold
              // Unsigned arithmetic handles millis() wraparound correctly
              return (millis() - id(last_temp_update_ms)) > ${comms_timeout_ms}UL;
          then:
            - lambda: |-
                id(comms_fault_latched) = true;
                ESP_LOGE("safety", "EMERGENCY: Temperature telemetry stale for >${comms_timeout_ms}ms, forcing emergency stop");
            - switch.turn_on: emergency_stop

  - interval: 180s
    then:
      # Check Home Assistant API communication
      - if:
          condition:
            lambda: 'return { (id(api_connection) != true) };'
          then:
            - if:
                condition: # Check if it is *now* connected
                  api.connected: # Check if it is now connected
                then:
                  # Actions when just connected
                  - lambda: "id(api_connection) = true;"
                else:
                  - lambda: |-
                      id(api_connection) = false;
                      ESP_LOGW("safety", "EMERGENCY: Home Assistant API connection lost, forcing emergency stop");
                  - switch.turn_on: emergency_stop
    
web_server:
  port: 80
  version: 3
  css_include: "www/webserver-v3.min.css"
  js_include: "www/pixel-stars.js"
#  js_include: "www/moving-particles.js"
#  js_include: "www/shooting-stars.js"
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
  sorting_groups:
    - id: sorting_group_sensors
      name: "Sensors"
      sorting_weight: 1
    - id: sorting_group_settings
      name: "Settings"
      sorting_weight: 2
    - id: sorting_group_diagnostic
      name: "Diagnostic"
      sorting_weight: 3
    - id: sorting_group_system
      name: "System Management"
      sorting_weight: 4
      
